return("Invalid element symbol")
}
}
# Example usage
unlist(sapply(unique(DAT$Analyte), get_element_name))
jit = position_jitter(height=0, width=dmonths(6), seed=123)
jit = position_jitter(height=0, width=0.15, seed=123)
# plt1 = dat %>% plotData_even("Si", jit=jit)
dat$Lab = factor(dat$Lab, levels = c("LANL", "INL",  "AWE",  "ANL", "SRS", "LLNL"), labels = c("Lab 1", "Lab 2", "Lab 3", "Lab 4", "Lab 5", "Lab 6"))
method_pal <- setNames(
object = unlist(alphabet(23)),
nm = c("ICPMS", "ICPAES", "GAMMA", "GAMMA1","GAMMA2",
"TIMS", "GAMMA3", "IR", "XRF", "SPEC", "ALPHA",
"CORPEL", "CPC", "KPA", "TIMS-IDMS", "IDMS",
"MCICPMS", "LECO","ICP-AES-S","IC","TC","IGF","BSSP-TIMS")
)
plt1 = dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 18, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 14),
legend.text = element_text(size = 14)
) + ylim(0,100)
# scale_x_discrete(labels = c("ANL" = "Lab 1", "AWE" = "Lab 2", "INL" = "Lab 3", "LANL" = "LANL"))
print(plt1)
plt1 = dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 18, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 14),
legend.text = element_text(size = 14)
) + ylim(0,100)
dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 18, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 14),
legend.text = element_text(size = 14)
) + ylim(0,100)
plotData_even <- function(dataSet, elname, jit=position_jitter(height=0, width=0, seed=123), method_pal) {
# Two plot cases:
#      - general case for plotting measurements by exchange date
#      - special case where there's only one exchange date
# Legends:
#      - method (color)
#      - censoring (shape)
shape_breaks <- c(TRUE, FALSE)
shape_values <- c(0,19)
shape_labels <- c("Recorded as DL", "Recorded Value")
line_breaks <- c(TRUE, FALSE)
line_values <- c(1, 0)
line_labels <- c("Recorded as DL", "Recorded Value")
if(sum(dataSet$Censored) == 0) yllim = min(dataSet$Results) else yllim = 0
# Case 1: general case of plotting censored and not censored observations
gg_dataSet <- dataSet %>%
ggplot(aes(x = factor(year(`Exchange Date`)), y = Results, color = `Method Code`,
shape = Censored, linetype = Censored)) +
geom_pointrange(aes(ymin=yllim, ymax=Results),position=jit,
alpha=0.5, fatten=6, size=1, stroke=0.5) +
scale_shape_manual(breaks = shape_breaks, values = shape_values,
labels = shape_labels, limits = force, name = "Observation Type") +
scale_linetype_manual(breaks=line_breaks, values = line_values, labels=line_labels, name="Observation Type") +
facet_grid(.~`Lab`, scales="free_x", space="free_x") +
theme_bw() +
theme(
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = "bottom",
axis.text.x = element_text(angle = 60, vjust = 1, hjust=1, size = 10),
axis.text.y = element_text(size=10), axis.title.x = element_text(size = 12),
axis.title.y = element_text(size=12),
panel.spacing=unit(0.15, "lines"),
panel.grid.minor = element_blank(),
strip.text.x = element_text(size = 10, angle = 60),
strip.clip = "off") +
scale_color_manual(values = method_pal, limits=force) +
guides(color = guide_legend(override.aes = list(linetype = "blank") ) ) + # hide lines on method legend
labs(title = paste(elname, "Measured Values", sep=" "),
x = "Exchange Date", y = dataSet$Units[1])
## Case 2: pretty up cases where there's only a single exchange date
# if(length(unique(dataSet$`Exchange Date`)) == 1){
#   gg_dataSet <- gg_dataSet +
#     xlim(min(DAT$`Exchange Date`),max(DAT$`Exchange Date`))
#     #scale_x_datetime(date_breaks = "2 months", date_labels =  "%b %Y")
# }
# gg_dataSet <- gg_dataSet + xlim(mindate-dmonths(6),maxdate+dmonths(6))
return(gg_dataSet)
# Notes:
# problem: geom_line sorts its data, so jitter doesn't apply in same order as for geom_point.
# solution: geom_pointrange
}
jit = position_jitter(height=0, width=dmonths(6), seed=123)
jit = position_jitter(height=0, width=0.15, seed=123)
# plt1 = dat %>% plotData_even("Si", jit=jit)
dat$Lab = factor(dat$Lab, levels = c("LANL", "INL",  "AWE",  "ANL", "SRS", "LLNL"), labels = c("Lab 1", "Lab 2", "Lab 3", "Lab 4", "Lab 5", "Lab 6"))
method_pal <- setNames(
object = unlist(alphabet(23)),
nm = c("ICPMS", "ICPAES", "GAMMA", "GAMMA1","GAMMA2",
"TIMS", "GAMMA3", "IR", "XRF", "SPEC", "ALPHA",
"CORPEL", "CPC", "KPA", "TIMS-IDMS", "IDMS",
"MCICPMS", "LECO","ICP-AES-S","IC","TC","IGF","BSSP-TIMS")
)
plt1 = dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20)
) + ylim(0,100)
# scale_x_discrete(labels = c("ANL" = "Lab 1", "AWE" = "Lab 2", "INL" = "Lab 3", "LANL" = "LANL"))
print(plt1)
dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20)
) + ylim(0,100)
# Label imputation conditions:
# - uncensored values
# - censored values above largest uncensored value are discarded from all analyses
# - censored values within range of recorded uncensored values will be imputed via ROS
# - censored values below smallest uncensored value are substituted with its DL
minMeas = min(dat$Results[!dat$Censored]) # min of uncensored measurements
maxMeas = max(dat$Results[!dat$Censored]) # max of uncensored measurements
dat$imputeCondition=ifelse(dat$Censored, "Impute via ROS","Recorded Value")
dat$imputeCondition[dat$Results > maxMeas] = "Noninformative"
dat$imputeCondition[dat$Results < minMeas] = "Substitute DL"
anyImputation <- any(dat$imputeCondition=="Impute via ROS") # should this include substitution of small nondetects?
anySubstitution <- any(dat$imputeCondition=="Substitute DL")
anyNoninformative <- any(dat$imputeCondition=="Noninformative")
dat <- dat %>% filter(dat$imputeCondition!="Noninformative")
nInformative <- dim(dat)[1] #N-sum(dat$imputeCondition=="Noninformative") # initial count
plt1b = dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)
print(plt1b)
impute.list <- imputeAnyCensored(dat)
# [1] dataset with add column with imputed values (via ROS and substituting DL)
# [2] ros object
dat.imputed <- impute.list$dataSet #%>% filter(!is.na(imputedResults)) # because NAs in imputedResults are noninformative censored
# dat.imputed has all recorded values, substituted DL, and imputed via ROS (drop noninformative censored??)
# update nInformative after checking for influential points
nInformative <- sum(dat.imputed$imputeCondition!="Noninformative")
if(is.na(any(dat.imputed$influential))){
nInfluential <- "-"
} else { # if any imputed, update count of influential
nInfluential <- sum(dat.imputed$influential==TRUE, na.rm=TRUE)
}
# update conditions
anyCensored <- sum(dat.imputed$Censored)>0 # substitute DL or impute via ROS
Method <- ifelse(anyCensored, "ROS Bootstrap", "Regular Bootstrap") # should this instead be set before or after removing noninformative? (e.g. if censored values are all noninformative, there is no need for ROS. bootstrap resamples from raw data including censored, but it will never introduce informative censored)
anyImputation <- any(dat.imputed$imputeCondition=="Impute via ROS")
anySubstitution <- any(dat.imputed$imputeCondition=="Substitute DL")
anyNoninformative = any(dat.imputed$imputeCondition=="Noninformative")
#ifelse(anyNoninformative,"After excluding any influential observations, censored values with detection limits greater than all remaining uncensored recorded values are treated as noninformative and are not imputed.","")
# if any censored values are imputed via ROS, plot the ROS regression
# - show the pre-imputation DLs for censored observations
# - show influential observations
# - show the censored obs smaller than smallest uncensored
# - show uncensored obs used for ROS fit
# plot ROS fit, if any obs to impute
# plot using impute.list$dataSet includes noninformative censored
# to only include informative censored, plot dat.imputed instead of impute.list$dataSet
ggROS <- plotROSwithDLs(dat.imputed, impute.list$ros)
#ggROS <- plotROSwithDLs(impute.list$dataSet, impute.list$ros)
print(ggROS)
r <- 0.25*nInformative
dat.imputed <- generalized_esd_v2(dat.imputed, r)  # includes identified outliers
nOutliers <- sum(dat.imputed$Outlier)
nOutliersLANL <- dim(filter(dat.imputed, Lab=="LANL" & Outlier))[1]
if(nOutliers>0){ #if outliers detected, plot full data by lab, with outliers, imputed values, and recorded DLs plotted as unique symbols
#set shape and method color palettes for plot
# method_pal <- setNames(
#   object = c("#7fb3da", "#C0997F", "#7f88d5", "#a17fd5", "#885F6D",
#              "#d57fb3", "#d57f88", "#69b3a2", "#b3d57f", "#CAC27F", "#88d57f",
#              "#d5a17f", "#7fd5cc", "#d7baba", "#AAB1AE", "#AAB1AE", "#f5d0aa",
#              "#8A9A5B", "#cc5500",
#              "#d57f88", "#885F6D","#a17fd5"),
#   nm = c("ICPMS", "ICPAES", "GAMMA", "GAMMA1","GAMMA2",
#          "TIMS", "GAMMA3", "IR", "XRF", "SPEC", "ALPHA",
#          "CORPEL", "CPC", "KPA", "TIMSIDMS", "TIMS-IDMS", "IDMS",
#          "MCICPMS", "LECO",
#          "TC","IC","IGF"))
shape_pal <- setNames(object = c(13, 9, 7, 0, 5, 19),
nm = c("Outlier", "Outlier (Imputed)", "Outlier (DL)", "Substituted DL", "Imputed via ROS", "Recorded Value"))
ggOutlier <- dat.imputed %>%
filter(!is.na(imputedResults)) %>%
ggplot(aes(x=factor(year(`Exchange Date`)), y=imputedResults,
color=`Method Code`, fill = `Method Code`, shape= ObsType)) +
geom_point(size=3,alpha=0.7,position=jit) +
theme_bw() +
facet_grid(.~`Lab`, scales="free_x", space="free_x") +
theme(
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = "bottom",
panel.grid.minor = element_blank(),
panel.spacing=unit(0.15, "lines"),
axis.text.x = element_text(angle = 60, vjust = 1, hjust=1, size = 10),
axis.text.y = element_text(size=10),
axis.title.x = element_text(size = 12), axis.title.y = element_text(size=12),
strip.text.x = element_text(size = 10, angle = 60),
strip.clip = "off") +
scale_color_manual(values = method_pal, limits=force) +
scale_shape_manual(values = shape_pal, limits=force, name="Observation Type") +
labs(title = paste("Si", "(Generalized ESD)", sep=" "),
x="Exchange Date", y=dat.imputed$Units[1])
print(ggOutlier)
}
## reclassify noninformative?
minMeas.new = min(dat.imputed$Results[!dat.imputed$Censored & !dat.imputed$Outlier]) # min of uncensored not-outlying measurements
maxMeas.new = max(dat.imputed$Results[!dat.imputed$Censored & !dat.imputed$Outlier]) # max of uncensored not-outlying measurements
# if any more dat.imputed$Results > maxMeas.new, then remove these new "Noninformative" obs from dat.imputed.nooutliers
dat.imputed$imputeCondition[dat.imputed$Censored & dat.imputed$imputedResults>maxMeas.new] <- "Noninformative"
# update nInformative after checking for outliers
nInformative <- sum(dat.imputed$imputeCondition!="Noninformative")
consensus.mean <- mean(dat.imputed$imputedResults[!dat.imputed$Outlier & dat.imputed$imputeCondition!="Noninformative"])
consensus.sd <- sd(dat.imputed$imputedResults[!dat.imputed$Outlier& dat.imputed$imputeCondition!="Noninformative"] )
# rounded for printing
consensus.mean.pretty <- round_custom(consensus.mean,"Si")
consensus.sd.pretty <- round_match(consensus.sd,consensus.mean.pretty)
ggQQ <- dat.imputed %>% filter(!is.na(log_Results)) %>%
qq(consensus.mean, consensus.sd)
print(ggQQ)
RES <- boot_ci_moderate_censoring(dat, n.boots, omit.outliers=TRUE)
BOOT.mean.LB <- as.numeric(RES[1,1])
BOOT.mean.UB <- as.numeric(RES[2,1])
BOOT.sd.LB <- as.numeric(RES[1,2])
BOOT.sd.UB <- as.numeric(RES[2,2])
# rounded for printing
BOOT.mean.LB.pretty <- round_match(BOOT.mean.LB,consensus.mean.pretty)
BOOT.mean.UB.pretty <- round_match(BOOT.mean.UB,consensus.mean.pretty)
BOOT.sd.LB.pretty <- round_match(BOOT.sd.LB,consensus.mean.pretty)
BOOT.sd.UB.pretty <- round_match(BOOT.sd.UB,consensus.mean.pretty)
dat.imputed %>%
plotConsensus(jit=jit, mu=consensus.mean, sigma=consensus.sd, mu.LB=BOOT.mean.LB, mu.UB=BOOT.mean.UB, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20),
# legend.position = 'none'
) #+ ylim(0,100)
dat.imputed %>%
plotConsensus(jit=jit, mu=consensus.mean, sigma=consensus.sd, mu.LB=BOOT.mean.LB, mu.UB=BOOT.mean.UB, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20),
# legend.position = 'none'
)
dat <- DAT %>% filter(Analyte=="{{thisel}}") %>% mutate(Censored = !is.na(`Less Than`))
dat.cpy <- dat # just for notes at end on which labs/methods omitted
dat <- DAT %>% filter(Analyte=="Si") %>% mutate(Censored = !is.na(`Less Than`))
N = dim(dat)[1]
#dat$id <- 1:N
dat <- dat %>% add_column(id=1:N)
thisel.units <- dat$Units[1]
anyCensored0 = sum(dat$Censored)>0
get_element_name <- function(symbol) {
# Periodic Table: Element Symbols and Names
elements <- c(
H = "Hydrogen", He = "Helium", Li = "Lithium", Be = "Beryllium", B = "Boron",
C = "Carbon", N = "Nitrogen", O = "Oxygen", F = "Fluorine", Ne = "Neon",
Na = "Sodium", Mg = "Magnesium", Al = "Aluminum", Si = "Silicon", P = "Phosphorus",
S = "Sulfur", Cl = "Chlorine", Ar = "Argon", K = "Potassium", Ca = "Calcium",
Sc = "Scandium", Ti = "Titanium", V = "Vanadium", Cr = "Chromium", Mn = "Manganese",
Fe = "Iron", Co = "Cobalt", Ni = "Nickel", Cu = "Copper", Zn = "Zinc",
Ga = "Gallium", Ge = "Germanium", As = "Arsenic", Se = "Selenium", Br = "Bromine",
Kr = "Krypton", Rb = "Rubidium", Sr = "Strontium", Y = "Yttrium", Zr = "Zirconium",
Nb = "Niobium", Mo = "Molybdenum", Tc = "Technetium", Ru = "Ruthenium", Rh = "Rhodium",
Pd = "Palladium", Ag = "Silver", Cd = "Cadmium", In = "Indium", Sn = "Tin",
Sb = "Antimony", Te = "Tellurium", I = "Iodine", Xe = "Xenon", Cs = "Cesium",
Ba = "Barium", La = "Lanthanum", Ce = "Cerium", Pr = "Praseodymium", Nd = "Neodymium",
Pm = "Promethium", Sm = "Samarium", Eu = "Europium", Gd = "Gadolinium", Tb = "Terbium",
Dy = "Dysprosium", Ho = "Holmium", Er = "Erbium", Tm = "Thulium", Yb = "Ytterbium",
Lu = "Lutetium", Hf = "Hafnium", Ta = "Tantalum", W = "Tungsten", Re = "Rhenium",
Os = "Osmium", Ir = "Iridium", Pt = "Platinum", Au = "Gold", Hg = "Mercury",
Tl = "Thallium", Pb = "Lead", Bi = "Bismuth", Po = "Polonium", At = "Astatine",
Rn = "Radon", Fr = "Francium", Ra = "Radium", Ac = "Actinium", Th = "Thorium",
Pa = "Protactinium", U = "Uranium", Np = "Neptunium", Pu = "Plutonium", Am = "Americium",
Cm = "Curium", Bk = "Berkelium", Cf = "Californium", Es = "Einsteinium", Fm = "Fermium",
Md = "Mendelevium", No = "Nobelium", Lr = "Lawrencium", Rf = "Rutherfordium", Db = "Dubnium",
Sg = "Seaborgium", Bh = "Bohrium", Hs = "Hassium", Mt = "Meitnerium", Ds = "Darmstadtium",
Rg = "Roentgenium", Cn = "Copernicium", Nh = "Nihonium", Fl = "Flerovium", Mc = "Moscovium",
Lv = "Livermorium", Ts = "Tennessine", Og = "Oganesson"
)
# Convert input to character and check if it's valid
symbol <- as.character(symbol)
if (symbol %in% names(elements)) {
return(elements[symbol])
} else {
return("Invalid element symbol")
}
}
# Example usage
unlist(sapply(unique(DAT$Analyte), get_element_name))
jit = position_jitter(height=0, width=dmonths(6), seed=123)
jit = position_jitter(height=0, width=0.15, seed=123)
# plt1 = dat %>% plotData_even("Si", jit=jit)
dat$Lab = factor(dat$Lab, levels = c("LANL", "INL",  "AWE",  "ANL", "SRS", "LLNL"), labels = c("Lab 1", "Lab 2", "Lab 3", "Lab 4", "Lab 5", "Lab 6"))
method_pal <- setNames(
object = unlist(alphabet(23)),
nm = c("ICPMS", "ICPAES", "GAMMA", "GAMMA1","GAMMA2",
"TIMS", "GAMMA3", "IR", "XRF", "SPEC", "ALPHA",
"CORPEL", "CPC", "KPA", "TIMS-IDMS", "IDMS",
"MCICPMS", "LECO","ICP-AES-S","IC","TC","IGF","BSSP-TIMS")
)
plt1 = dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20)
) + ylim(0,100)
# scale_x_discrete(labels = c("ANL" = "Lab 1", "AWE" = "Lab 2", "INL" = "Lab 3", "LANL" = "LANL"))
print(plt1)
dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20)
) + ylim(0,100)
dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20)
)
# Label imputation conditions:
# - uncensored values
# - censored values above largest uncensored value are discarded from all analyses
# - censored values within range of recorded uncensored values will be imputed via ROS
# - censored values below smallest uncensored value are substituted with its DL
minMeas = min(dat$Results[!dat$Censored]) # min of uncensored measurements
maxMeas = max(dat$Results[!dat$Censored]) # max of uncensored measurements
dat$imputeCondition=ifelse(dat$Censored, "Impute via ROS","Recorded Value")
dat$imputeCondition[dat$Results > maxMeas] = "Noninformative"
dat$imputeCondition[dat$Results < minMeas] = "Substitute DL"
anyImputation <- any(dat$imputeCondition=="Impute via ROS") # should this include substitution of small nondetects?
anySubstitution <- any(dat$imputeCondition=="Substitute DL")
anyNoninformative <- any(dat$imputeCondition=="Noninformative")
dat <- dat %>% filter(dat$imputeCondition!="Noninformative")
nInformative <- dim(dat)[1] #N-sum(dat$imputeCondition=="Noninformative") # initial count
plt1b = dat %>% plotData_even("Si", jit=jit, method_pal = method_pal)
print(plt1b)
impute.list <- imputeAnyCensored(dat)
# [1] dataset with add column with imputed values (via ROS and substituting DL)
# [2] ros object
dat.imputed <- impute.list$dataSet #%>% filter(!is.na(imputedResults)) # because NAs in imputedResults are noninformative censored
# dat.imputed has all recorded values, substituted DL, and imputed via ROS (drop noninformative censored??)
# update nInformative after checking for influential points
nInformative <- sum(dat.imputed$imputeCondition!="Noninformative")
if(is.na(any(dat.imputed$influential))){
nInfluential <- "-"
} else { # if any imputed, update count of influential
nInfluential <- sum(dat.imputed$influential==TRUE, na.rm=TRUE)
}
# update conditions
anyCensored <- sum(dat.imputed$Censored)>0 # substitute DL or impute via ROS
Method <- ifelse(anyCensored, "ROS Bootstrap", "Regular Bootstrap") # should this instead be set before or after removing noninformative? (e.g. if censored values are all noninformative, there is no need for ROS. bootstrap resamples from raw data including censored, but it will never introduce informative censored)
anyImputation <- any(dat.imputed$imputeCondition=="Impute via ROS")
anySubstitution <- any(dat.imputed$imputeCondition=="Substitute DL")
anyNoninformative = any(dat.imputed$imputeCondition=="Noninformative")
#ifelse(anyNoninformative,"After excluding any influential observations, censored values with detection limits greater than all remaining uncensored recorded values are treated as noninformative and are not imputed.","")
# if any censored values are imputed via ROS, plot the ROS regression
# - show the pre-imputation DLs for censored observations
# - show influential observations
# - show the censored obs smaller than smallest uncensored
# - show uncensored obs used for ROS fit
# plot ROS fit, if any obs to impute
# plot using impute.list$dataSet includes noninformative censored
# to only include informative censored, plot dat.imputed instead of impute.list$dataSet
ggROS <- plotROSwithDLs(dat.imputed, impute.list$ros)
#ggROS <- plotROSwithDLs(impute.list$dataSet, impute.list$ros)
print(ggROS)
r <- 0.25*nInformative
dat.imputed <- generalized_esd_v2(dat.imputed, r)  # includes identified outliers
nOutliers <- sum(dat.imputed$Outlier)
nOutliersLANL <- dim(filter(dat.imputed, Lab=="LANL" & Outlier))[1]
if(nOutliers>0){ #if outliers detected, plot full data by lab, with outliers, imputed values, and recorded DLs plotted as unique symbols
#set shape and method color palettes for plot
# method_pal <- setNames(
#   object = c("#7fb3da", "#C0997F", "#7f88d5", "#a17fd5", "#885F6D",
#              "#d57fb3", "#d57f88", "#69b3a2", "#b3d57f", "#CAC27F", "#88d57f",
#              "#d5a17f", "#7fd5cc", "#d7baba", "#AAB1AE", "#AAB1AE", "#f5d0aa",
#              "#8A9A5B", "#cc5500",
#              "#d57f88", "#885F6D","#a17fd5"),
#   nm = c("ICPMS", "ICPAES", "GAMMA", "GAMMA1","GAMMA2",
#          "TIMS", "GAMMA3", "IR", "XRF", "SPEC", "ALPHA",
#          "CORPEL", "CPC", "KPA", "TIMSIDMS", "TIMS-IDMS", "IDMS",
#          "MCICPMS", "LECO",
#          "TC","IC","IGF"))
shape_pal <- setNames(object = c(13, 9, 7, 0, 5, 19),
nm = c("Outlier", "Outlier (Imputed)", "Outlier (DL)", "Substituted DL", "Imputed via ROS", "Recorded Value"))
ggOutlier <- dat.imputed %>%
filter(!is.na(imputedResults)) %>%
ggplot(aes(x=factor(year(`Exchange Date`)), y=imputedResults,
color=`Method Code`, fill = `Method Code`, shape= ObsType)) +
geom_point(size=3,alpha=0.7,position=jit) +
theme_bw() +
facet_grid(.~`Lab`, scales="free_x", space="free_x") +
theme(
legend.direction = "vertical",
legend.box = "horizontal",
legend.position = "bottom",
panel.grid.minor = element_blank(),
panel.spacing=unit(0.15, "lines"),
axis.text.x = element_text(angle = 60, vjust = 1, hjust=1, size = 10),
axis.text.y = element_text(size=10),
axis.title.x = element_text(size = 12), axis.title.y = element_text(size=12),
strip.text.x = element_text(size = 10, angle = 60),
strip.clip = "off") +
scale_color_manual(values = method_pal, limits=force) +
scale_shape_manual(values = shape_pal, limits=force, name="Observation Type") +
labs(title = paste("Si", "(Generalized ESD)", sep=" "),
x="Exchange Date", y=dat.imputed$Units[1])
print(ggOutlier)
}
## reclassify noninformative?
minMeas.new = min(dat.imputed$Results[!dat.imputed$Censored & !dat.imputed$Outlier]) # min of uncensored not-outlying measurements
maxMeas.new = max(dat.imputed$Results[!dat.imputed$Censored & !dat.imputed$Outlier]) # max of uncensored not-outlying measurements
# if any more dat.imputed$Results > maxMeas.new, then remove these new "Noninformative" obs from dat.imputed.nooutliers
dat.imputed$imputeCondition[dat.imputed$Censored & dat.imputed$imputedResults>maxMeas.new] <- "Noninformative"
# update nInformative after checking for outliers
nInformative <- sum(dat.imputed$imputeCondition!="Noninformative")
consensus.mean <- mean(dat.imputed$imputedResults[!dat.imputed$Outlier & dat.imputed$imputeCondition!="Noninformative"])
consensus.sd <- sd(dat.imputed$imputedResults[!dat.imputed$Outlier& dat.imputed$imputeCondition!="Noninformative"] )
# rounded for printing
consensus.mean.pretty <- round_custom(consensus.mean,"Si")
consensus.sd.pretty <- round_match(consensus.sd,consensus.mean.pretty)
ggQQ <- dat.imputed %>% filter(!is.na(log_Results)) %>%
qq(consensus.mean, consensus.sd)
print(ggQQ)
RES <- boot_ci_moderate_censoring(dat, n.boots, omit.outliers=TRUE)
BOOT.mean.LB <- as.numeric(RES[1,1])
BOOT.mean.UB <- as.numeric(RES[2,1])
BOOT.sd.LB <- as.numeric(RES[1,2])
BOOT.sd.UB <- as.numeric(RES[2,2])
# rounded for printing
BOOT.mean.LB.pretty <- round_match(BOOT.mean.LB,consensus.mean.pretty)
BOOT.mean.UB.pretty <- round_match(BOOT.mean.UB,consensus.mean.pretty)
BOOT.sd.LB.pretty <- round_match(BOOT.sd.LB,consensus.mean.pretty)
BOOT.sd.UB.pretty <- round_match(BOOT.sd.UB,consensus.mean.pretty)
dat.imputed %>%
plotConsensus(jit=jit, mu=consensus.mean, sigma=consensus.sd, mu.LB=BOOT.mean.LB, mu.UB=BOOT.mean.UB, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20),
# legend.position = 'none'
) #+ ylim(0,100)
dat.imputed %>%
plotConsensus(jit=jit, mu=consensus.mean, sigma=consensus.sd, mu.LB=BOOT.mean.LB, mu.UB=BOOT.mean.UB, method_pal = method_pal)+
theme(
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.text.x = element_text(size = 20),
strip.text.x = element_text(size = 20, angle = 0),
axis.title.y = element_text(size = 20),
axis.text.y = element_text(size = 20),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20),
# legend.position = 'none'
)
